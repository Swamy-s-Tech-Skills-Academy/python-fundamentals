---
learning_level: "Nerd ‚Üí Novice"
prerequisites:
  - "docs/sessions/L2/03_S3.md"
estimated_time: "30 minutes"
session_type: "Knowledge"
learning_objectives:
  - "Understand why error handling is essential"
  - "Use try/except blocks to handle errors gracefully"
  - "Handle specific exceptions (ValueError, TypeError, etc.)"
  - "Use else and finally clauses appropriately"
  - "Write robust programs that don't crash"
  - "Distinguish between different error types"
related_topics:
  prerequisites:
    - "docs/sessions/L2/03_S3.md"
    - "docs/sessions/L1/07_S6.md"
  builds_upon:
    - "docs/sessions/L1/07_S6.md"
    - "docs/sessions/L2/03_S3.md"
  enables:
    - "docs/sessions/L2/05_MP1.md"
    - "docs/sessions/L2/08_S7.md"
  cross_refs: []
---

# Session 4: Error Handling: try/except Basics

**Duration:** 30 minutes  
**Type:** üìö Knowledge  
**Level:** Nerd ‚Üí Novice

---

## üéØ **Session Overview & Agenda**

### **What You'll Learn:**

- ‚úÖ Understand why error handling matters
- ‚úÖ Use `try/except` blocks to catch errors
- ‚úÖ Handle specific exceptions (ValueError, TypeError, FileNotFoundError)
- ‚úÖ Use `else` and `finally` clauses
- ‚úÖ Write programs that handle errors gracefully
- ‚úÖ Distinguish between different error types

### **Session Flow:**

| Part | Activity                        | Description                                                                                |
| ---- | ------------------------------- | ------------------------------------------------------------------------------------------ |
| 1    | Why Error Handling?             | Understanding the importance of error handling                                             |
| 2    | Basic try/except                | Catching and handling errors                                                               |
| 3    | Specific Exceptions             | Handling different types of errors                                                         |
| 4    | else and finally                | Additional clauses for error handling                                                     |
| 5    | Common Exceptions               | ValueError, TypeError, FileNotFoundError, and more                                        |
| 6    | Hands-on Practice               | Practice files demonstrating error handling                                                |

---

## üìã **Before You Begin**

### **Prerequisites:**

‚úÖ Completed [Session 3: Functions: Definition & Basics](docs/sessions/L2/03_S3.md)  
‚úÖ Understand basic debugging from [Level 1 Session 6](docs/sessions/L1/07_S6.md)  
‚úÖ Know how to read error messages  
‚úÖ Comfortable with functions and basic Python syntax

---

## üíª **Part 1: Why Error Handling?**

### **The Problem: Programs That Crash**

Without error handling, your program crashes when something goes wrong:

```python
# This will crash if user enters non-number
age = int(input("Enter your age: "))
print(f"You are {age} years old.")
```

**What happens if user enters "twenty"?**
```
ValueError: invalid literal for int() with base 10: 'twenty'
```

The program stops, and the user sees an ugly error message!

### **The Solution: Error Handling**

Error handling lets your program **gracefully handle** problems instead of crashing:

```python
try:
    age = int(input("Enter your age: "))
    print(f"You are {age} years old.")
except ValueError:
    print("Please enter a valid number!")
```

Now the program continues even if the user makes a mistake!

### **Benefits of Error Handling**

- ‚úÖ **User-friendly**: Show helpful messages instead of errors
- ‚úÖ **Robust**: Programs don't crash unexpectedly
- ‚úÖ **Professional**: Handle edge cases gracefully
- ‚úÖ **Debuggable**: Know what went wrong and where

---

## üíª **Part 2: Basic try/except**

### **The try/except Structure**

```python
try:
    # Code that might cause an error
    risky_code()
except:
    # What to do if an error occurs
    handle_error()
```

### **Simple Example**

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"10 divided by {number} = {result}")
except:
    print("Something went wrong! Please try again.")
```

**What happens:**
- If user enters valid number: calculation runs normally
- If user enters invalid input or 0: error message shows, program continues

### **Catching Specific Errors**

It's better to catch specific errors:

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"10 divided by {number} = {result}")
except ValueError:
    print("That's not a valid number!")
except ZeroDivisionError:
    print("Can't divide by zero!")
```

**Why this is better:**
- ‚úÖ More specific error messages
- ‚úÖ Handle different errors differently
- ‚úÖ Easier to debug

---

## üíª **Part 3: Specific Exceptions**

### **Common Exception Types**

Python has many built-in exception types:

| Exception | When It Occurs |
|-----------|----------------|
| `ValueError` | Wrong value type (e.g., `int("abc")`) |
| `TypeError` | Wrong type operation (e.g., `"5" + 3`) |
| `ZeroDivisionError` | Dividing by zero |
| `FileNotFoundError` | File doesn't exist |
| `IndexError` | List index out of range |
| `KeyError` | Dictionary key doesn't exist |

### **Handling Multiple Exceptions**

You can handle multiple exceptions:

```python
try:
    number = int(input("Enter a number: "))
    result = 100 / number
    print(f"Result: {result}")
except ValueError:
    print("Please enter a valid number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
except Exception:
    print("An unexpected error occurred!")
```

**Order matters:** More specific exceptions should come first!

---

## üíª **Part 4: else and finally Clauses**

### **The else Clause**

Code in `else` runs only if no exception occurred:

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ValueError:
    print("Invalid number!")
except ZeroDivisionError:
    print("Can't divide by zero!")
else:
    print(f"Success! Result: {result}")
    print("Calculation completed successfully.")
```

**Flow:**
- If error occurs ‚Üí except block runs, else is skipped
- If no error ‚Üí try block runs, then else block runs

### **The finally Clause**

Code in `finally` **always runs**, whether there's an error or not:

```python
try:
    file = open("data.txt", "r")
    content = file.read()
    print(content)
except FileNotFoundError:
    print("File not found!")
finally:
    print("This always runs!")
    # Good place for cleanup code
```

**Use `finally` for:**
- Closing files
- Cleaning up resources
- Logging completion

### **Complete Structure**

```python
try:
    # Code that might fail
    risky_operation()
except SpecificError:
    # Handle specific error
    handle_error()
except Exception:
    # Handle any other error
    handle_other_error()
else:
    # Runs if no error occurred
    success_code()
finally:
    # Always runs
    cleanup_code()
```

---

## üíª **Part 5: Common Exceptions in Practice**

### **ValueError - Invalid Value**

```python
try:
    age = int(input("Enter your age: "))
    print(f"Age: {age}")
except ValueError:
    print("Please enter a number, not text!")
```

### **TypeError - Wrong Type**

```python
try:
    result = "5" + 3  # Can't add string and int
except TypeError:
    print("Type mismatch! Can't add string and number.")
```

### **ZeroDivisionError - Division by Zero**

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"Result: {result}")
except ZeroDivisionError:
    print("Cannot divide by zero!")
except ValueError:
    print("Please enter a valid number!")
```

### **FileNotFoundError - Missing File**

```python
try:
    with open("data.txt", "r") as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("File 'data.txt' not found!")
```

### **IndexError - List Index Out of Range**

```python
try:
    items = ["apple", "banana", "cherry"]
    print(items[5])  # Index 5 doesn't exist!
except IndexError:
    print("Index out of range! List only has 3 items.")
```

---

## üöÄ **Part 6: Hands-on Practice**

### **Practice File 1: Basic Error Handling**

üß™ *Practice Files*:  
`src/L2/S4/01_basic_error_handling.py`

```python
# Filename: src/L2/S4/01_basic_error_handling.py
# Session 4: Error Handling - Basics

# Handle ValueError
try:
    age = int(input("Enter your age: "))
    print(f"You are {age} years old.")
except ValueError:
    print("Please enter a valid number!")

# Handle ZeroDivisionError
try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"10 / {number} = {result}")
except ValueError:
    print("That's not a number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
```

### **Practice File 2: Multiple Exception Types**

üß™ *Practice Files*:  
`src/L2/S4/02_multiple_exceptions.py`

```python
# Filename: src/L2/S4/02_multiple_exceptions.py
# Session 4: Error Handling - Multiple Exceptions

# Handle different error types
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except TypeError:
        print("Error: Both values must be numbers!")
        return None
    except ZeroDivisionError:
        print("Error: Cannot divide by zero!")
        return None

# Test the function
print(safe_divide(10, 2))    # Works: 5.0
print(safe_divide(10, 0))    # ZeroDivisionError handled
print(safe_divide("10", 2))   # TypeError handled
```

### **Practice File 3: else and finally**

üß™ *Practice Files*:  
`src/L2/S4/03_else_finally.py`

```python
# Filename: src/L2/S4/03_else_finally.py
# Session 4: Error Handling - else and finally

# Using else clause
try:
    number = int(input("Enter a number: "))
    result = number ** 2
except ValueError:
    print("Invalid input!")
else:
    print(f"Square of {number} is {result}")
    print("Calculation successful!")

# Using finally clause
try:
    file = open("test.txt", "r")
    content = file.read()
    print(content)
except FileNotFoundError:
    print("File not found!")
finally:
    print("This always runs, whether file exists or not!")
```

---

## üìù **Key Takeaways**

- **Error handling** prevents programs from crashing unexpectedly
- **try/except blocks** catch and handle errors gracefully
- **Specific exceptions** provide better error messages and handling
- **else clause** runs when no error occurs
- **finally clause** always runs (great for cleanup)
- **Common exceptions**: ValueError, TypeError, ZeroDivisionError, FileNotFoundError

---

## üîß **Troubleshooting**

### **Common Issues:**

**Issue:** Catching all exceptions with bare `except:`  
**Solution:** Be specific! Catch `ValueError`, `TypeError`, etc. instead of catching everything

**Issue:** Exception order matters  
**Solution:** Put more specific exceptions before general ones

**Issue:** Code in `finally` not running  
**Solution:** `finally` always runs - if it's not, there might be a syntax error

---

## üîó **What's Next?**

You've completed Phase A! Now it's time for **Mini Project 1: Data Processor** where you'll apply sets, tuples, list comprehensions, functions, and error handling!

**Related Sessions:**
- [Mini Project 1: Data Processor](docs/sessions/L2/05_MP1.md) - Apply all Phase A concepts
- [Session 5: Functions: Parameters & Return Values](docs/sessions/L2/06_S5.md) - Make functions more powerful

---

‚ú® Happy Coding! üêç

